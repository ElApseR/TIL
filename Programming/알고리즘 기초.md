# 알고리즘 기초

*이 글은 <a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a>를 정리하였습니다.*  

*이 글은 또한 <a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">[Algorithm] 알고리즘 공부 시작 방법 및 순서</a>를 참고하였습니다.*

*모든 예시 코드는 python3 기준으로 새롭게 구현하였습니다.*

---

## 1. 알고리즘이란?

- 어떠한 문제를 해결하기 위한 일련의 절차를 공식화한 형태로 표현한 것이다.
    - 문제를 단순히 해결하는 것이 아니라, 정확하고 효율적으로 해결하고자 하는 것이다.
- 프로그래밍을 '건물을 짓는 법'이라고 한다면, **알고리즘은 '건물을 설계하는 법'** 이다.
    - 두 가지 모두 건물을 완성하는 데에 없어서는 안 되는 과정이다.
    - 건물을 짓는 법이 다양하듯, 건물을 설계하는 법 역시 다양하다. 이때, 건물의 설계가 어떻게 되었는가에 따라 속도와 처리 방법이 영향을 받는다.

## 2. 어떻게 공부해야 할까?
1. 기본 개념 이해
    - 시간 복잡도
    - 자료구조
    - 정렬
2. 기본 알고리즘 코드 구현
3. 다양한 문제에 적용해보기

## 3. 기본 개념 이해

### 3-1. 시간 복잡도

방에 물건이 어지럽게 널려있고, 이를 치워야하는 상황을 상상해보자. 방에 널려있는 물건이 많을 수록 물건을 모두 치우는데에 시간이 오래 걸릴 것이다. 이처럼 입력된 자료의 크기는 알고리즘을 수행하는 데에 걸리는 시간에 어느 정도 영향을 미친다. 이것을 시간 복잡도라고 한다. 즉, 시간 복잡도는 **입력된 자료의 크기와 알고리즘을 거쳐 출력을 하기까지 소요되는 시간의 관계를 나타내는 함수** 이다.

ex) 1부터 n까지의 합을 구하는 두 종류의 코드가 있다.

~~~python
# 방법 1
n = int(input('insert n'))
result = 0

for i in range(1,n+1):
    result += i
print(result)
~~~

~~~python
# 방법 2
n = int(input('insert n'))
result = 0

result = n*(n+1)/2
print(result)
~~~

방법 1의 경우, for문을 사용하여 입력되는 자연수 n만큼의 연산이 수행된다. 이와 달리, 방법 2는 중학교 때 배운 기초적인 수학 공식을 활용하여 자연수 n의 크기와 무관하게 단 한 번의 연산이 수행된다. 사람이 조금 더 고생하면 컴퓨터가 조금 덜 고생한다.

이처럼 알고리즘은 입력된 데이터의 크기 및 갯수에 따라 계산 횟수가 바뀌고, 그에 따른 수행시간이 바뀐다. 이렇듯 **입력받는 데이터의 크기에 따른 알고리즘의 수행시간 변화** 를 시간 복잡도라고 한다. 시간 복잡도를 나타내는 방식으로는 일반적으로 Big O 를 활용한다. Big O는 수학에서 사용하는 점근 표기법과 동일한 개념이며, 즉 알고리즘의 수행시간이 bounded 되어있다는 것을 의미하기 위해 사용된다. n번의 계산이 필요한 알고리즘은 O(n)의 시간복잡도를 가진다고 표현하며, 2n번의 계산이 필요한 알고리즘은 O(2n)의 시간복잡도를 가진다고 말한다. 하지만 점근 표기법의 특성상 상수는 무시해도 무관하며, 가장 최고차항을 기준으로 써준다(참고:<a href="https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95">위키백과</a>). 즉, 2n^2 + 3n 번 연산을 수행하는 알고리즘은 O(n^2)의 시간 복잡도를 가진다고 말한다. 위의 예시에서 '방법 1'은 O(n)의 시간 복잡도를 가지며, '방법 2'는 O(1)의 시간 복잡도를 가진다. 알고리즘의 형태별 시간 복잡도는 아래와 같으며, 아래쪽으로 갈 수록 더 시간 복잡도가 큰(오래 걸리는) 알고리즘이다.

|시간 복잡도|설명|
|---|---|
|O(1)|상수 형태이며, n과 무관하게 일정한 상수 번 계산한다.|
|O(logn)|n에 대해 로그 형태|
|O(n)|n에 대해 선형|
|O(nlogn)|n에 대해 선형로그 형태|
|O(n^2),O(n^3),⋯|n에 대해 다차 형태|
|O(2^n)|n에 대해 지수 형태|
|O(n!)|n에 대해 팩토리얼 형태|

코딩 테스트 및 프로그래밍 대회에서는 코드가 돌아가는 데에 시간 제한이 존재하기 때문에 시간 복잡도를 고려하는 것이 중요하다. 이때, 문제에서 n의 갯수에 제한이 있을 것이며, 본인의 알고리즘의 O(~)에 n의 상한을 넣어서 계산해보면, 대략적으로 코드가 돌아가는데에 걸리는 시간을 예측해볼 수 있다. 대략적으로 잡았을 때, big O의 값이 1천만 ~ 10억 사이일 경우, 1초의 제한시간에 적합한 프로그램이라고 본다.

## 4. 자료구조

<img src="https://wayhome25.github.io/assets/post-img/cs/data-structure.png">
*image from <a href="https://wayhome25.github.io/cs/2017/04/17/cs-18/">초보몽키의 개발공부로그</a>*

자료를 저장하는 방식을 의미한다. 주어지는 데이터에 적절한 자료구조를 선택하는 것은 효율적인 알고리즘 작성에 필수적이다. 효율적인 자료구조는 시간복잡도와 공간복잡도(저장 공간의 크기)가 낮다. 데이터를 어떤 구조로 저장하고, 탐색하고, 삭제해야하는지 알아보자.

### 4-1. 선형 자료 구조

한 종류의 데이터가 선처럼 길게 나열된 구조이다.

#### 4-1.1. 랜덤 접근 가능
- 배열
- 해시

모든 자료에 O(1)으로 접근이 가능한 구조이다.

##### 4-1.1.1. 배열

가장 쉬운 자료구조이며, 어떤 프로그래밍 언어를 사용하는지에 따라 그 사용법이 가장 크게 달라지는 자료구조이다. 파이썬에서는 리스트를 활용하며, 대괄호를 묶음으로서 사용할 수 있다.

~~~python
array1 = [1,2,3]
~~~

##### 4-1.1.2. 해시

해시는 해시함수를 활용하여 구현한다(해시함수란, 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다). 배열과 마찬가지로 원소를 찾는데에 O(1)의 시간복잡도를 가진다(항상 그런 것만은 아니다). key-value가 매칭되어있는 형태를 가지고 있으며, 해시함수에 키 값을 넣어 주소값을 얻은 뒤, 해당 주소에 저장된 데이터를 가져오는 방식이다. 파이썬에서는 dictionary라는 자료형이 해시에 해당한다.

~~~python
hash = {1:'aa', 2:'bb'}
~~~

#### 4-1.2. 랜덤 접근 불가능
- 스택
- 큐

모든 자료에 O(1)으로 접근이 보장되지 않는 자료구조이다.

##### 4-1.2.1. 스택

먼저 들어간 자료가 나중에 나오는 구조(후입선출)이다. 동전탑을 쌓은 뒤 이를 분해할 때, 먼저 쌓은 동전일 수록 나중에 뺄 수 있는 것과 동일하다. 일반적으로 자료를 넣는 **push** 함수와 자료를 뽑는 **pop** 함수를 가지고 있다.
~~~ python
class stack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def peek(self):
        return self.items[-1]

    def size(self):
        return len(self.items)

    # python list가 가지고 있는 자체 pop method 이용
    def pop(self):
        return self.items.pop()

    # pop의 정의대로 새로 만든 pop 메소드
    def pop_custom(self):
        returning_value = self.items[-1]
        self.items = self.items[:-1]
        return returning_value
~~~

~~~python
def reverseString(str):
	s = stack()
	result = ""
	for i in str:
		s.push(i)
	while s.isEmpty() != True:
		result += s.pop_custom()
	return result

>>> print(reverseString("apple"))
elppa
~~~

##### 4-1.2.2. 큐
먼저 들어간 자료가 먼저 나오는 구조이다(선입선출). 영어로 '줄'을 queue라고 하는데, 말 그대로 먼저 줄 선 사람이 먼저 나온다는 의미이다(직관적이다). 자료를 넣는 **Enqueue** 함수 및 자료를 빼는 **Dequeue** 함수를 가진다.

~~~python
class queue:
	def __init__(self):
		self.items = []

	def enqueue(self, item):
		self.items.insert(0, item)

    # 파이썬 리스트의 기본 pop method를 활용한다.
	def dequeue(self):
		return self.items.pop()

	def isEmpty(self):
		return self.items == []

	def size(self):
		return len(self.items)

q = queue()
for i in 'apple':
    q.enqueue(i)
while q.isEmpty() != True:
    q.dequeue()
~~~

##### 4-1.2.3 데크
스택과 큐의 중간쯤에 위치해있다. 양쪽 끝에서 삽입과 삭제가 가능하다. 보통 입력이나 출력 중 하나를 한쪽 입구로만 가능하게 하는 형태로 활용된다.

##### 4-1.2.4 링크드 리스트

*아래 내용은 잘 와닿지 않아, <a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a>에서 그대로 가져왔습니다.*

연결 리스트라고도 불린다. 값과 다음 노드를 가지고 있다. 옵션으로 이전 노드를 가지게 할 수도 있으며, 맨 뒤 노드가 맨 앞 노드를 다음 노드로 가지게 할 수도 있다. 또한, 중간에서 삽입과 삭제를 할 수 있다. 가장 간단하게 구현한 것은 위의 큐. 다시 한 번 뜯어보고 옵션을 넣어본다면 실력 향상에 도움이 될 것이다. 다만, 링크드 리스트는 원소들이 이곳저곳에 흩어져있어서 구현체의 속도가 느리기 때문에, 잘 사용되지는 않는 편이다.

#### 4-1.3 선형구조 자료의 탐색법
선형 구조로 된 자료를 탐색하는 법을 설명한다. 일반적으로 어떤 값이 어떤 위치에 있는지를 알아내는 게 목적이다.

##### 4-1.3.1 순차 탐색
말 그대로 해당 자료의 시작점부터 끝까지 순서대로 하나씩 탐색하는 것이다. 모든 성분에 대해 한번씩 수행한다면, 시간복잡도는 O(n)이다.

~~~python
myarray = [1,2,3,4,5]

# 일치하는 성분을 찾으면 멈추는 것으로 한다.
def linear_search(array,x):
    for i, element in enumerate(array):
        if element == x:
            return i

>>>linear_search(myarray, 3)
2        
~~~

##### 4-1.3.2 이분 탐색

특수한 경우 순차 탐색보다 좀 더 빠른 속도를 갖는 알고리즘으로, O(log_2(N))의 시간 복잡도를 가진다. 자료의 가운데(중위값)부터 시작하여 매번 일정 조건에 따라 어떤 방향의 가운데 값으로 이동하여 탐색하는 알고리즘이다.

> 배열 1 3 4 7 8 13 17에서 '8'이 있는 위치를 찾는다고 가정하자.
> 배열: 1 3 4 7 8 13 17
> 1st:총 배열의 가운데인 7을 선택.
> 7<8 이므로 더 큰 숫자가 있는 오른쪽으로 진행.
> 2nd:7~17의 배열중 가운데인 13을 선택.
> 13>8 이므로 더 작은 숫자가 있는 왼쪽으로 진행.
> 3rd:7과 13의 가운데에 있는 8을 선택.
> 8=8 이고 배열은 5번째이므로 답은 5이다.

개인적으로 통계 전산 시간에 배운 bisection algorithm을 이용하여 해를 찾는 방법과 비슷하다고 생각된다. 사실 거의 동일한 것 같다.
