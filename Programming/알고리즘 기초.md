# 알고리즘 기초

*이 글은 <a href="https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88">시리즈:수학인듯 과학아닌 공학같은 컴퓨터과학/알고리즘 기초</a>를 정리하였습니다.*  

*이 글은 또한 <a href="https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html">[Algorithm] 알고리즘 공부 시작 방법 및 순서</a>를 참고하였습니다.*

*모든 예시 코드는 python3 기준으로 새롭게 구현하였습니다.*

---

## 1. 알고리즘이란?

- 어떠한 문제를 해결하기 위한 일련의 절차를 공식화한 형태로 표현한 것이다.
    - 문제를 단순히 해결하는 것이 아니라, 정확하고 효율적으로 해결하고자 하는 것이다.
- 프로그래밍을 '건물을 짓는 법'이라고 한다면, **알고리즘은 '건물을 설계하는 법'** 이다.
    - 두 가지 모두 건물을 완성하는 데에 없어서는 안 되는 과정이다.
    - 건물을 짓는 법이 다양하듯, 건물을 설계하는 법 역시 다양하다. 이때, 건물의 설계가 어떻게 되었는가에 따라 속도와 처리 방법이 영향을 받는다.

## 2. 어떻게 공부해야 할까?
1. 기본 개념 이해
    - 시간 복잡도
    - 자료구조
    - 정렬
2. 기본 알고리즘 코드 구현
3. 다양한 문제에 적용해보기

## 3. 기본 개념 이해

### 3-1. 시간 복잡도

방에 물건이 어지럽게 널려있고, 이를 치워야하는 상황을 상상해보자. 방에 널려있는 물건이 많을 수록 물건을 모두 치우는데에 시간이 오래 걸릴 것이다. 이처럼 입력된 자료의 크기는 알고리즘을 수행하는 데에 걸리는 시간에 어느 정도 영향을 미친다. 이것을 시간 복잡도라고 한다. 즉, 시간 복잡도는 **입력된 자료의 크기와 알고리즘을 거쳐 출력을 하기까지 소요되는 시간의 관계를 나타내는 함수** 이다.

ex) 1부터 n까지의 합을 구하는 두 종류의 코드가 있다.

~~~python
# 방법 1
n = int(input('insert n'))
result = 0

for i in range(1,n+1):
    result += i
print(result)
~~~

~~~python
# 방법 2
n = int(input('insert n'))
result = 0

result = n*(n+1)/2
print(result)
~~~

방법 1의 경우, for문을 사용하여 입력되는 자연수 n만큼의 연산이 수행된다. 이와 달리, 방법 2는 중학교 때 배운 기초적인 수학 공식을 활용하여 자연수 n의 크기와 무관하게 단 한 번의 연산이 수행된다. 사람이 조금 더 고생하면 컴퓨터가 조금 덜 고생한다.

이처럼 알고리즘은 입력된 데이터의 크기 및 갯수에 따라 계산 횟수가 바뀌고, 그에 따른 수행시간이 바뀐다. 이렇듯 **입력받는 데이터의 크기에 따른 알고리즘의 수행시간 변화** 를 시간 복잡도라고 한다. 시간 복잡도를 나타내는 방식으로는 일반적으로 Big O 를 활용한다. Big O는 수학에서 사용하는 점근 표기법과 동일한 개념이며, 즉 알고리즘의 수행시간이 bounded 되어있다는 것을 의미하기 위해 사용된다. n번의 계산이 필요한 알고리즘은 O(n)의 시간복잡도를 가진다고 표현하며, 2n번의 계산이 필요한 알고리즘은 O(2n)의 시간복잡도를 가진다고 말한다. 하지만 점근 표기법의 특성상 상수는 무시해도 무관하며, 가장 최고차항을 기준으로 써준다(참고:<a href="https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95">위키백과</a>). 즉, 2n^2 + 3n 번 연산을 수행하는 알고리즘은 O(n^2)의 시간 복잡도를 가진다고 말한다. 위의 예시에서 '방법 1'은 O(n)의 시간 복잡도를 가지며, '방법 2'는 O(1)의 시간 복잡도를 가진다. 알고리즘의 형태별 시간 복잡도는 아래와 같으며, 아래쪽으로 갈 수록 더 시간 복잡도가 큰(오래 걸리는) 알고리즘이다.

|시간 복잡도|설명|
|---|---|
|O(1)|상수 형태이며, n과 무관하게 일정한 상수 번 계산한다.|
|O(logn)|n에 대해 로그 형태|
|O(n)|n에 대해 선형|
|O(nlogn)|n에 대해 선형로그 형태|
|O(n^2),O(n^3),⋯|n에 대해 다차 형태|
|O(2^n)|n에 대해 지수 형태|
|O(n!)|n에 대해 팩토리얼 형태|

코딩 테스트 및 프로그래밍 대회에서는 코드가 돌아가는 데에 시간 제한이 존재하기 때문에 시간 복잡도를 고려하는 것이 중요하다. 이때, 문제에서 n의 갯수에 제한이 있을 것이며, 본인의 알고리즘의 O(~)에 n의 상한을 넣어서 계산해보면, 대략적으로 코드가 돌아가는데에 걸리는 시간을 예측해볼 수 있다. 대략적으로 잡았을 때, big O의 값이 1천만 ~ 10억 사이일 경우, 1초의 제한시간에 적합한 프로그램이라고 본다. 
